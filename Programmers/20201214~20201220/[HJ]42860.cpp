#include <string>
#include <vector>
#include <queue>
using namespace std;

int solution(string name) {
    int size=name.size(), answer=0;
    queue<int> q;
    
    for(int i=0; i<size; i++)
    {
        // val: 알파벳 변환 횟수
        int val = name[i] - 'A';
        // ▲키 보다 ▼가 유리할 경우, ▼키.
        answer += (val > 13) ? 26 - val : val;
        if(val > 0) q.push(i);
    }
    
    int dis=INT32_MAX;
    while(!q.empty())
    {
        int qFirst = q.front();
        q.pop();
        // 정방향 탐색
        if(q.empty()) dis = (qFirst < dis) ? qFirst : dis;
        // qFirst까지 탐색 후, 역탐색(qSecond까지).
        else
        {
            int qSecond = q.front();
            // qFirst*2 (정방향 왕복 탐색 거리) + size - qSecond (역방향 탐색 거리)
            int comp = qFirst*2 + size - qSecond;
            dis = (comp < dis) ? comp : dis; 
        }        
    }
    
    return answer+dis;
}
/*
 * 채점을 시작합니다.
 * 정확성  테스트
 * 테스트 1 〉	통과 (0.01ms, 3.95MB)
 * 테스트 2 〉	통과 (0.01ms, 3.98MB)
 * 테스트 3 〉	통과 (0.01ms, 3.97MB)
 * 테스트 4 〉	통과 (0.01ms, 3.79MB)
 * 테스트 5 〉	통과 (0.01ms, 3.71MB)
 * 테스트 6 〉	통과 (0.01ms, 3.95MB)
 * 테스트 7 〉	통과 (0.01ms, 3.96MB)
 * 테스트 8 〉	통과 (0.01ms, 3.96MB)
 * 테스트 9 〉	통과 (0.01ms, 3.96MB)
 * 테스트 10 〉	통과 (0.01ms, 3.97MB)
 * 테스트 11 〉	통과 (0.01ms, 3.96MB)
 * 채점 결과
 * 정확성: 100.0
 * 합계: 100.0 / 100.0
 * 점수: 9점
 */
 
 /*
  * ### 풀이 ###
  * 이 문제에서는 두 가지를 구현해야 했다.
  * 1. 상하 버튼 (알파벳 변경)
  * 2. 좌우 버튼 (위치 이동)
  * 
  * 이 중 2번의 경우가 이 문제의 핵심이었는데, 2번 때문에 몇 시간을 헤맸던 거 같다.
  * 처음엔 단순히, A[1]의 값이 'A'이면 역방향 탐색을 하려고 했다.
  * 하지만, 정방향 탐색에서 size-n (n이 2보다 클 때)이 'A'일 경우도 고려해야 한단걸 깨달았다.
  * 그래서 양방향으로 'A'가 나오지 않을 때까지, 숫자를 세어 많이 나온 쪽을 빼어 전체 size - cnt 를 해주었다.
  * 그랬더니, BBABBB 와 같은... 중간에 A가 나와 방향을 변경해야 하는 경우가 있다는 걸 깨닫게 되었다...
  * 
  * 문제를 다시 읽게 되었다.(아마도 5번 이상...) 이 문제는 왜 그리디인가?
  * 어떤 부분에서 우선순위를 두어야 하는 것일까?
  * 질문하기를 탐색 중, 아주 중요한 힌트를 얻게 되었다.
  * 왼쪽으로 이동할 경우, 0 -> size-1 로 이동이 가능하지만, 오른쪽으로 이동할 경우 size-1 -> 0 으로 이동이 불가능하단 것이다.
  * 그래서 정방향 탐색을 먼저 한 후, 역방향 탐색을 하려고 코드를 구현 하였으나,
  * 어느 시점에서 역방향 탐색을 해야 하는지 알 수 없었다.
  * 처음에는 큐 or 덱을 이용하여 현재 탐색 위치와 정방향, 역방향까지의 거리를 이용하여 방향을 전환하려 했으나,
  * ABAAABAAAAAAAAAAB 와 같은 경우, 두번 째 B가 아닌, 첫 번째 B에서 방향을 전환하는 문제가 생겼다.
  * 
  * 이후에 든 생각은, 완전 탐색을 해야 한다고 생각했다.
  * 분할 정복을 이용하여, 모든 시점에서 정방향 탐색과 역방향 탐색을 했을 때, 이동거리를 구해 가장 작은쪽을 가져오는 것이다.
  * 구현에 앞서 이 로직의 탐색 횟수가 쓸때없이 많은거 같다는 생각이 들어 탐색 횟수를 줄이는 법을 고민했다.
  * 한참을 고민하는데, 변환할 알파벳을 담아놓은 큐가 눈에 띄었다.
  * 큐에 담긴 값을 모두 탐색할 경우, 정방향 탐색을 한 것이다.
  * 큐에 담긴 첫 번째 값을 정방향 탐색할 때, 역방향으로 변경한다면 첫 번째 값의 거리 * 2 + 큐의 두번째 값까지 역방향 탐색 거리이다.
  * 해결 완료.
  * 
  * 1번의 경우에는 알파벳에서 'A'를 빼줄 경우, 정수가 되는 것을 이용하였다.
  * 알파벳은 26개 이므로 절반인 13을 넘기면 26에 val 값을 빼, 최대 13회까지 버튼을 누르도록 만들었다.
  * 끝.
  */ 